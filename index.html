<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tasker</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>‚úÖ</text></svg>">

    <style>
        :root {
            --bg-body: #f4f7f6;
            --bg-sidebar: #e1e8e8;
            --bg-container: #ffffff;
            --text-primary: #333;
            --text-secondary: #666;
            --border-color: #ccc;
            --btn-primary: #3498db;
            --btn-hover: #2980b9;
            --sidebar-width: 260px;
            --active-item: #dbe9f4;
            --deleted-bg: #ffecec;
            --deleted-border: #ffcccc;
            --deleted-text: #c0392b;
            --outline-color: #fff; /* Default outline for dark text */
        }

        body.dark-mode {
            --bg-body: #121212;
            --bg-sidebar: #1a1a1a;
            --bg-container: #252525;
            --text-primary: #e0e0e0;
            --text-secondary: #aaa;
            --border-color: #444;
            --btn-primary: #2980b9;
            --active-item: #333;
            --deleted-bg: #3e1a1a;
            --deleted-border: #682828;
            --deleted-text: #e74c3c;
            --outline-color: #000; /* Dark outline for light text */
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: var(--bg-body);
            color: var(--text-primary);
            margin: 0;
            height: 100vh;
            display: flex;
            overflow: hidden;
            transition: background-color 0.3s, color 0.3s;
        }

        /* --- TEXT OUTLINE UTILITY --- */
        .text-outline {
            text-shadow: 
                -1px -1px 0 var(--outline-color),  
                 1px -1px 0 var(--outline-color),
                -1px  1px 0 var(--outline-color),
                 1px  1px 0 var(--outline-color);
            letter-spacing: 0.5px;
        }

        /* --- LAYOUT --- */
        .app-layout { display: flex; width: 100%; height: 100%; }

        /* --- SIDEBAR --- */
        .sidebar {
            width: var(--sidebar-width);
            background: var(--bg-sidebar);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
            transition: background-color 0.3s;
        }

        .sidebar-header {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* User Profile Box */
        .user-profile-box {
            background: rgba(0,0,0,0.05);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            border: 1px solid var(--border-color);
        }
        .user-avatar {
            width: 30px; height: 30px; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            color: #fff; 
            font-weight: bold; font-size: 14px;
            border: 1px solid rgba(0,0,0,0.1);
            text-shadow: 0 0 2px rgba(0,0,0,0.5);
        }
        .user-info { flex-grow: 1; overflow: hidden; }
        
        .user-name-display { 
            font-weight: 800; 
            font-size: 15px; 
            white-space: nowrap; 
            overflow: hidden; 
            text-overflow: ellipsis; 
        }

        .edit-name-btn {
            background: none; border: none; cursor: pointer; font-size: 14px; color: var(--text-secondary);
        }
        .edit-name-btn:hover { color: var(--btn-primary); }

        .team-list { list-style: none; padding: 0; flex-grow: 1; overflow-y: auto; }

        .team-item {
            padding: 10px 15px; margin-bottom: 5px; border-radius: 6px;
            cursor: pointer; display: flex; justify-content: space-between;
            align-items: center; transition: background 0.2s;
        }
        .team-item:hover { background: rgba(0,0,0,0.05); }
        .team-item.active { background: var(--active-item); font-weight: 600; border-left: 4px solid var(--btn-primary); }

        .sidebar-controls { margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 15px; }

        /* Toggle Switch */
        .toggle-row { display: flex; align-items: center; justify-content: space-between; font-size: 13px; margin-bottom: 10px; }
        .switch { position: relative; display: inline-block; width: 34px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 14px; width: 14px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--btn-primary); }
        input:checked + .slider:before { transform: translateX(14px); }

        .add-team-btn {
            width: 100%; padding: 10px; background: transparent;
            border: 1px dashed var(--border-color); color: var(--text-secondary);
            cursor: pointer; border-radius: 6px;
        }
        .add-team-btn:hover { border-color: var(--btn-primary); color: var(--btn-primary); }

        /* --- MAIN CONTENT --- */
        .main-content {
            flex-grow: 1; padding: 30px; overflow-y: auto;
            background: var(--bg-container); display: flex; flex-direction: column; align-items: center;
            transition: background-color 0.3s;
        }
        .content-wrapper { width: 600px; max-width: 100%; }

        /* --- MODAL --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: none; justify-content: center; align-items: center; z-index: 1000;
        }
        .modal-box {
            background: var(--bg-container); padding: 30px; border-radius: 10px;
            text-align: center; width: 300px; border: 1px solid var(--border-color);
        }
        .modal-input {
            width: 90%; padding: 10px; margin: 15px 0;
            border: 1px solid var(--border-color); border-radius: 5px;
            background: var(--bg-body); color: var(--text-primary);
        }

        /* --- NETWORK PANEL --- */
        .network-panel {
            background: rgba(0,0,0,0.03); border: 1px solid var(--border-color);
            padding: 15px; border-radius: 8px; margin-bottom: 20px; font-size: 13px;
        }
        .my-id-box {
            background: var(--bg-container); padding: 8px; border: 1px dashed var(--border-color);
            cursor: pointer; text-align: center; margin-bottom: 10px; word-break: break-all;
            transition: background 0.2s;
        }
        .my-id-box:hover { background: rgba(0,0,0,0.05); }

        .connect-row { display: flex; gap: 5px; }
        .connect-input { 
            flex-grow: 1; padding: 6px; border: 1px solid var(--border-color); border-radius: 4px; 
            background: var(--bg-body); color: var(--text-primary);
        }
        .peer-list { margin-top: 10px; display: flex; flex-wrap: wrap; gap: 5px; }
        .peer-badge { background: #27ae60; color: white; padding: 2px 8px; border-radius: 10px; font-size: 11px; }

        /* --- TASKS --- */
        .header-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        h2 { margin: 0; }

        .input-group { display: flex; gap: 10px; margin-bottom: 20px; }
        input[type="text"] {
            flex-grow: 1; padding: 10px; border: 2px solid var(--border-color); border-radius: 6px;
            background: var(--bg-body); color: var(--text-primary);
        }
        button.action-btn {
            padding: 10px 15px; background: var(--btn-primary); color: white;
            border: none; border-radius: 6px; cursor: pointer;
        }
        
        ul { list-style: none; padding: 0; }
        
        li.task-item {
            background: var(--bg-body); border: 1px solid var(--border-color);
            border-left: 5px solid transparent; border-radius: 6px;
            margin-bottom: 10px; padding: 10px; display: flex; flex-direction: column;
            transition: transform 0.2s;
        }
        
        li.task-item.marked-deleted {
            background-color: var(--deleted-bg);
            border-color: var(--deleted-border);
            border-left-color: var(--deleted-text) !important;
        }
        li.task-item.marked-deleted .task-text {
            text-decoration: line-through;
            color: var(--deleted-text);
        }
        li.task-item.marked-deleted .delete-btn {
            background: var(--deleted-text); color: white; border-radius: 4px; padding: 2px 8px; font-weight: bold;
        }
        li.task-item.marked-deleted .delete-btn:hover { opacity: 0.8; }

        .task-main { display: flex; align-items: center; gap: 10px; }
        .task-text { flex-grow: 1; }
        .task-meta { font-size: 11px; color: var(--text-secondary); margin-left: 28px; margin-top: 2px; }
        .author-tag { font-weight: bold; }
        
        .completed .task-text { text-decoration: line-through; opacity: 0.6; }
        
        .subtask-list { margin-left: 30px; margin-top: 5px; border-top: 1px dashed var(--border-color); }
        .subtask-item { display: flex; align-items: center; gap: 10px; padding: 5px 0; font-size: 14px; }
        
        .delete-btn { background: transparent; color: #e74c3c; border:none; cursor: pointer; font-size: 14px; }
        .delete-btn:hover { opacity: 0.7; }

        .theme-btn { background: none; border:none; font-size: 20px; cursor: pointer; color: var(--text-primary); }
        
        @media (max-width: 700px) {
            .app-layout { flex-direction: column; }
            .sidebar { width: 100%; height: auto; max-height: 300px; padding: 10px; }
            .main-content { padding: 15px; }
        }
    </style>
</head>
<body>

    <!-- LOGIN / RENAME MODAL -->
    <div id="loginModal" class="modal-overlay" style="display: flex;">
        <div class="modal-box">
            <h3 id="modalTitle">Welcome to Tasker</h3>
            <p>Enter a nickname to identify yourself.</p>
            <input type="text" id="nicknameInput" class="modal-input" placeholder="Your Name" maxlength="15">
            <button class="action-btn" onclick="submitProfile()">Save Profile</button>
        </div>
    </div>

    <div class="app-layout">
        <!-- SIDEBAR -->
        <div class="sidebar">
            <div class="sidebar-header">
                <span>Tasker</span>
                <button class="theme-btn" id="themeToggleBtn" onclick="toggleTheme()">üåô</button>
            </div>

            <!-- User Profile (Hidden Cache ID) -->
            <div class="user-profile-box">
                <div class="user-avatar" id="userAvatar">?</div>
                <div class="user-info">
                    <div class="user-name-display text-outline" id="userNameDisplay">Anon</div>
                </div>
                <button class="edit-name-btn" onclick="openProfileModal()" title="Change Name">‚úé</button>
            </div>
            
            <div style="font-size:12px; font-weight:bold; margin-bottom:5px; color:var(--text-secondary);">TEAMS</div>
            <ul class="team-list" id="teamListUi"></ul>
            
            <div class="sidebar-controls">
                <div class="toggle-row">
                    <span>Auto-delete incoming</span>
                    <label class="switch">
                        <input type="checkbox" id="autoDeleteToggle" onchange="toggleAutoDelete()">
                        <span class="slider"></span>
                    </label>
                </div>
                <button class="add-team-btn" onclick="createNewTeam()">+ New Team</button>
            </div>
        </div>

        <!-- MAIN CONTENT -->
        <div class="main-content">
            <div class="content-wrapper">
                
                <div class="header-row">
                    <h2 id="currentTeamTitle">Loading...</h2>
                    <button class="delete-btn" onclick="deleteCurrentTeam()" title="Delete this team list">üóëÔ∏è</button>
                </div>

                <!-- NETWORK PANEL -->
                <div class="network-panel">
                    <div class="my-id-box" onclick="copyId()" title="Click to Copy Shareable Link">
                        <span id="myIdDisplay">Connecting to network...</span>
                    </div>
                    <div class="connect-row">
                        <input type="text" id="peerIdInput" class="connect-input" placeholder="Paste a friend's ID">
                        <button class="action-btn" onclick="connectToPeer()">Connect</button>
                    </div>
                    <div class="peer-list" id="peerList"></div>
                </div>

                <!-- TASK INPUT -->
                <div class="input-group">
                    <input type="text" id="mainInput" placeholder="Add a new task...">
                    <button class="action-btn" onclick="addTask()">Add</button>
                </div>

                <ul id="taskList"></ul>
            </div>
        </div>
    </div>

    <script>
        // --- STATE & IDENTITY ---
        let user = { id: null, name: 'Anon', color: '#3498db' };
        let peerProfiles = {}; 
        let appData = {}; 
        let activeListId = null;
        let settings = { autoDelete: false };

        // Pre-seed with hardcoded defaults in case fetch fails
        let customColors = {
            "mmk1102": "#000000",
            "author": "#000000"
        };

        let peer = null;
        let connections = {}; 
        let myPeerId = null;

        // --- INITIALIZATION ---
        
        // 1. Load or Generate Identity (Hidden Cache)
        const storedId = localStorage.getItem('taskerUserId');
        if (storedId) {
            user.id = storedId;
        } else {
            user.id = 'user-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('taskerUserId', user.id);
        }

        // 2. Load Profiles
        const storedProfiles = localStorage.getItem('taskerProfiles');
        if (storedProfiles) peerProfiles = JSON.parse(storedProfiles);

        // 3. Load Data
        const savedData = localStorage.getItem('taskerMesh_v4');
        if (savedData) {
            appData = JSON.parse(savedData);
            activeListId = Object.keys(appData)[0];
        } else {
            const defId = 'team-' + Date.now();
            appData[defId] = { name: 'General', tasks: [] };
            activeListId = defId;
        }

        // 4. Load Settings
        const savedSettings = localStorage.getItem('taskerSettings');
        if(savedSettings) settings = JSON.parse(savedSettings);
        document.getElementById('autoDeleteToggle').checked = settings.autoDelete;

        // 5. Fetch Custom Colors
        async function loadCustomColors() {
            try {
                // Add timestamp to prevent caching
                const response = await fetch('https://mmk1102x.github.io/tasker/users.json?t=' + Date.now());
                if (response.ok) {
                    const data = await response.json();
                    // Normalize to lowercase keys
                    for (let key in data) {
                        customColors[key.toLowerCase()] = data[key];
                    }
                    // Refresh UI in case colors changed
                    if (user.name) {
                        user.color = stringToColor(user.name);
                        updateProfileUI();
                        renderTasks();
                    }
                }
            } catch (e) {
                console.log("Using default/hardcoded colors (Fetch failed or file missing)");
            }
        }
        loadCustomColors();

        // 6. Check Login Status
        if (peerProfiles[user.id]) {
            user.name = peerProfiles[user.id].name;
            user.color = peerProfiles[user.id].color; // This might be stale, updated by loadCustomColors later
            document.getElementById('loginModal').style.display = 'none';
            initApp();
        } else {
            document.getElementById('loginModal').style.display = 'flex';
        }

        // --- THEME LOGIC ---
        function initTheme() {
            const savedTheme = localStorage.getItem('theme');
            const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const btn = document.getElementById('themeToggleBtn');

            if (savedTheme === 'dark') {
                document.body.classList.add('dark-mode');
                btn.innerText = '‚òÄÔ∏è';
            } else if (savedTheme === 'light') {
                document.body.classList.remove('dark-mode');
                btn.innerText = 'üåô';
            } else {
                if (systemPrefersDark) {
                    document.body.classList.add('dark-mode');
                    btn.innerText = '‚òÄÔ∏è';
                } else {
                    document.body.classList.remove('dark-mode');
                    btn.innerText = 'üåô';
                }
            }
        }
        initTheme();

        function toggleTheme() {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            document.getElementById('themeToggleBtn').innerText = isDark ? '‚òÄÔ∏è' : 'üåô';
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
        }

        // --- IDENTITY & PROFILE SYSTEM ---
        function stringToColor(str) {
            const lower = str.toLowerCase();
            
            // 1. Check Custom JSON Config (and hardcoded defaults)
            if (customColors[lower]) {
                return customColors[lower];
            }

            // 2. Fallback Hash Algorithm
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
            }
            const c = (hash & 0x00FFFFFF).toString(16).toUpperCase();
            return '#' + "00000".substring(0, 6 - c.length) + c;
        }

        function submitProfile() {
            const name = document.getElementById('nicknameInput').value.trim();
            if (!name) return alert("Name required");
            
            user.name = name;
            user.color = stringToColor(name);
            
            peerProfiles[user.id] = { name: user.name, color: user.color };
            saveProfiles();

            document.getElementById('loginModal').style.display = 'none';
            
            if (!peer) initApp();
            else {
                updateProfileUI();
                renderTasks();
                broadcastProfile(); 
            }
        }

        function openProfileModal() {
            document.getElementById('modalTitle').innerText = "Update Profile";
            document.getElementById('nicknameInput').value = user.name;
            document.getElementById('loginModal').style.display = 'flex';
        }

        function saveProfiles() {
            localStorage.setItem('taskerProfiles', JSON.stringify(peerProfiles));
        }

        function updateProfileUI() {
            // Recalculate color in case JSON loaded late
            user.color = stringToColor(user.name);
            
            const nameEl = document.getElementById('userNameDisplay');
            nameEl.innerText = user.name;
            nameEl.style.color = user.color; 
            
            const avatar = document.getElementById('userAvatar');
            avatar.style.backgroundColor = user.color;
            avatar.innerText = user.name.charAt(0).toUpperCase();
        }

        function initApp() {
            initNetwork();
            renderSidebar();
            renderTasks();
            updateProfileUI();
        }

        // --- SETTINGS ---
        function toggleAutoDelete() {
            settings.autoDelete = document.getElementById('autoDeleteToggle').checked;
            localStorage.setItem('taskerSettings', JSON.stringify(settings));
            renderTasks(); 
        }

        // --- SIDEBAR ---
        function renderSidebar() {
            const listUi = document.getElementById('teamListUi');
            listUi.innerHTML = '';
            Object.keys(appData).forEach(id => {
                const list = appData[id];
                const li = document.createElement('li');
                li.className = `team-item ${id === activeListId ? 'active' : ''}`;
                li.innerText = list.name;
                li.onclick = () => switchTeam(id);
                listUi.appendChild(li);
            });
            if(appData[activeListId]) document.getElementById('currentTeamTitle').innerText = appData[activeListId].name;
        }

        function createNewTeam() {
            const name = prompt("Enter Team Name:");
            if(!name) return;
            const newId = 'team-' + Date.now() + Math.random().toString(36).substr(2, 5);
            appData[newId] = { name: name, tasks: [] };
            switchTeam(newId);
        }

        function switchTeam(id) {
            activeListId = id;
            renderSidebar();
            renderTasks();
        }

        function deleteCurrentTeam() {
            if(Object.keys(appData).length <= 1) return alert("Cannot delete the last team.");
            if(!confirm("Delete this team?")) return;
            delete appData[activeListId];
            activeListId = Object.keys(appData)[0];
            saveData();
            renderSidebar();
            renderTasks();
        }

        // --- PEERJS & NETWORKING ---
        function initNetwork() {
            if(peer) return;
            peer = new Peer(); 
            peer.on('open', (id) => {
                myPeerId = id;
                document.getElementById('myIdDisplay').innerText = `My ID: ${id} (Click to Copy Link)`;
                
                const targetId = window.location.hash.substring(1);
                if(targetId && targetId !== myPeerId) {
                    document.getElementById('peerIdInput').value = targetId;
                    connectToPeer(targetId);
                }
            });
            peer.on('connection', (conn) => { handleConnection(conn); });
        }

        function connectToPeer(overrideId = null) {
            const remoteId = overrideId || document.getElementById('peerIdInput').value.trim();
            if (!remoteId || remoteId === myPeerId || connections[remoteId]) return;
            const conn = peer.connect(remoteId);
            handleConnection(conn);
        }

        function handleConnection(conn) {
            conn.on('open', () => {
                connections[conn.peer] = conn;
                updatePeerUI();
                
                conn.send({ type: 'PROFILE', id: user.id, name: user.name, color: user.color });

                if(appData[activeListId]) {
                    conn.send({ 
                        type: 'SYNC', 
                        listId: activeListId,
                        listName: appData[activeListId].name,
                        tasks: appData[activeListId].tasks 
                    });
                }
                
                const knownPeers = Object.keys(connections).filter(id => id !== conn.peer);
                if (knownPeers.length > 0) conn.send({ type: 'PEERS', peers: knownPeers });
            });

            conn.on('data', (msg) => {
                if (msg.type === 'SYNC') handleSyncMessage(msg);
                else if (msg.type === 'PROFILE') handleProfileMessage(msg);
                else if (msg.type === 'PEERS') {
                    msg.peers.forEach(pId => {
                        if (pId !== myPeerId && !connections[pId]) {
                            handleConnection(peer.connect(pId));
                        }
                    });
                }
            });
            conn.on('close', () => { delete connections[conn.peer]; updatePeerUI(); });
        }

        function broadcastProfile() {
            const payload = { type: 'PROFILE', id: user.id, name: user.name, color: user.color };
            Object.values(connections).forEach(conn => { if (conn.open) conn.send(payload); });
        }

        function broadcastData() {
            const payload = { 
                type: 'SYNC', 
                listId: activeListId,
                listName: appData[activeListId].name,
                tasks: appData[activeListId].tasks 
            };
            Object.values(connections).forEach(conn => { if (conn.open) conn.send(payload); });
        }

        function updatePeerUI() {
            const list = document.getElementById('peerList');
            list.innerHTML = '';
            Object.keys(connections).forEach(id => {
                const badge = document.createElement('span');
                badge.className = 'peer-badge';
                badge.innerText = id.substring(0, 4) + '...';
                list.appendChild(badge);
            });
        }

        function copyId() { 
            const url = window.location.origin + window.location.pathname + '#' + myPeerId;
            navigator.clipboard.writeText(url); 
            alert("Shareable Link Copied!"); 
        }

        // --- DATA HANDLING ---
        function handleProfileMessage(msg) {
            // Recalculate color using local logic (in case they don't have the JSON yet)
            const resolvedColor = stringToColor(msg.name);
            peerProfiles[msg.id] = { name: msg.name, color: resolvedColor };
            saveProfiles();
            renderTasks();
        }

        function handleSyncMessage(msg) {
            const { listId, listName, tasks: remoteTasks } = msg;
            if (!appData[listId]) {
                appData[listId] = { name: listName, tasks: [] };
                renderSidebar();
            }
            const localList = appData[listId];
            let changed = false;

            remoteTasks.forEach(remoteTask => {
                const localTask = localList.tasks.find(t => t.id === remoteTask.id);
                if (!localTask) {
                    localList.tasks.push(remoteTask);
                    changed = true;
                } else {
                    if (remoteTask.lastUpdated > localTask.lastUpdated) {
                        Object.assign(localTask, remoteTask);
                        changed = true;
                    }
                }
            });

            if (changed) {
                saveData();
                if (listId === activeListId) renderTasks();
            }
        }

        function saveData() { localStorage.setItem('taskerMesh_v4', JSON.stringify(appData)); }
        function saveAndBroadcast() { saveData(); renderTasks(); broadcastData(); }

        // --- TASK LOGIC ---
        function addTask() {
            const input = document.getElementById('mainInput');
            const text = input.value.trim();
            if (!text) return;

            const newTask = {
                id: myPeerId + '-' + Date.now(),
                text: text,
                completed: false,
                authorId: user.id, 
                author: user.name, 
                authorColor: user.color, 
                lastUpdated: Date.now(),
                deleted: false,
                deletedBy: null,
                subtasks: [],
                _localDismissed: false 
            };

            appData[activeListId].tasks.push(newTask);
            input.value = '';
            saveAndBroadcast();
        }

        function toggleTask(id) {
            const task = appData[activeListId].tasks.find(t => t.id === id);
            if (task) {
                task.completed = !task.completed;
                task.lastUpdated = Date.now();
                saveAndBroadcast();
            }
        }

        function markAsDeleted(id) {
            const task = appData[activeListId].tasks.find(t => t.id === id);
            if (task) {
                task.deleted = true;
                task.deletedBy = user.name;
                task.lastUpdated = Date.now();
                saveAndBroadcast();
            }
        }

        function dismissTask(id) {
            const task = appData[activeListId].tasks.find(t => t.id === id);
            if (task) {
                task._localDismissed = true; 
                saveData(); 
                renderTasks();
            }
        }

        // --- RENDERING ---
        function getAuthorDetails(task) {
            let info = { name: task.author, color: task.authorColor };
            
            // 1. Try to find author by ID in our profile map
            if (task.authorId && peerProfiles[task.authorId]) {
                info = peerProfiles[task.authorId];
            }
            
            // 2. Ensure color is up to date with current customColors config
            info.color = stringToColor(info.name);
            return info;
        }

        function renderTasks() {
            const ul = document.getElementById('taskList');
            ul.innerHTML = '';
            const currentTasks = appData[activeListId].tasks;

            const visibleTasks = currentTasks.filter(t => {
                if (t._localDismissed) return false; 
                if (t.deleted && settings.autoDelete) return false; 
                return true;
            }).sort((a,b) => b.lastUpdated - a.lastUpdated);

            visibleTasks.forEach(task => {
                const li = document.createElement('li');
                li.className = 'task-item';
                if (task.deleted) li.classList.add('marked-deleted');
                
                const authorInfo = getAuthorDetails(task);
                li.style.borderLeftColor = authorInfo.color;

                let actionBtn = '';
                if (task.deleted) {
                    actionBtn = `<button class="delete-btn" onclick="dismissTask('${task.id}')" title="Confirm Deletion">üóëÔ∏è Confirm</button>`;
                } else {
                    actionBtn = `<button class="delete-btn" onclick="markAsDeleted('${task.id}')">‚úï</button>`;
                }

                let statusText = '';
                if (task.deleted) {
                    statusText = `<span style="color:var(--deleted-text); font-weight:bold;">Deleted by ${task.deletedBy || 'someone'}</span>`;
                } else {
                    statusText = `Added by <span class="author-tag text-outline" style="color:${authorInfo.color}">${authorInfo.name}</span>`;
                }

                li.innerHTML = `
                    <div class="task-main">
                        <input type="checkbox" ${task.completed ? 'checked' : ''} ${task.deleted ? 'disabled' : ''} onchange="toggleTask('${task.id}')">
                        <span class="task-text ${task.completed ? 'completed' : ''}">${task.text}</span>
                        ${actionBtn}
                    </div>
                    <div class="task-meta">
                        ${statusText}
                    </div>
                `;

                if (!task.deleted) {
                    const subUl = document.createElement('div');
                    subUl.className = 'subtask-list';
                    task.subtasks.forEach(sub => {
                        const subDiv = document.createElement('div');
                        subDiv.className = 'subtask-item';
                        subDiv.innerHTML = `
                            <input type="checkbox" ${sub.completed ? 'checked' : ''} onchange="toggleSubtask('${task.id}', ${sub.id})">
                            <span style="flex-grow:1; ${sub.completed ? 'text-decoration:line-through; opacity:0.6' : ''}">${sub.text}</span>
                        `;
                        subUl.appendChild(subDiv);
                    });
                    li.appendChild(subUl);
                }

                ul.appendChild(li);
            });
        }

        function toggleSubtask(parentId, subId) {
            const task = appData[activeListId].tasks.find(t => t.id === parentId);
            const sub = task.subtasks.find(s => s.id === subId);
            if(sub) { sub.completed = !sub.completed; task.lastUpdated = Date.now(); saveAndBroadcast(); }
        }

        document.getElementById('mainInput').addEventListener('keypress', e => { if(e.key === 'Enter') addTask() });
    </script>
</body>
</html>